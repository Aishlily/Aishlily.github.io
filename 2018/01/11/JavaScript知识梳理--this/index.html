<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/love.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/love.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JavaScript," />










<meta name="description" content="this关键字是一个非常重要的语法点。this是属性或方法“当前”所在的对象。JavaScript 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，this就是函数运行时所在的对象（环境）。这本来并不会让用户糊涂，但是 JavaScript 支持运行环境动态切换，也就是说，this的指向是动态的，没有办法事先确定到底指向哪个对象。 只要函数被赋给另一个变量，this的指向就">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript知识梳理--this">
<meta property="og:url" content="/2018/01/11/JavaScript知识梳理--this/index.html">
<meta property="og:site_name" content="Aishlily&#39;s Blog">
<meta property="og:description" content="this关键字是一个非常重要的语法点。this是属性或方法“当前”所在的对象。JavaScript 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，this就是函数运行时所在的对象（环境）。这本来并不会让用户糊涂，但是 JavaScript 支持运行环境动态切换，也就是说，this的指向是动态的，没有办法事先确定到底指向哪个对象。 只要函数被赋给另一个变量，this的指向就">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-01-06T11:53:57.205Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript知识梳理--this">
<meta name="twitter:description" content="this关键字是一个非常重要的语法点。this是属性或方法“当前”所在的对象。JavaScript 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，this就是函数运行时所在的对象（环境）。这本来并不会让用户糊涂，但是 JavaScript 支持运行环境动态切换，也就是说，this的指向是动态的，没有办法事先确定到底指向哪个对象。 只要函数被赋给另一个变量，this的指向就">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="/2018/01/11/JavaScript知识梳理--this/"/>





  <title>JavaScript知识梳理--this | Aishlily's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Aishlily's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'urw61T1LFFwLwttU72jp','2.0.0');
</script>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2018/01/11/JavaScript知识梳理--this/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aishlily">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aishlily's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JavaScript知识梳理--this</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-11T16:45:45+08:00">
                2018-01-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript技术/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><code>this</code>关键字是一个非常重要的语法点。<code>this</code>是属性或方法“当前”所在的对象。JavaScript 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，<code>this</code>就是函数运行时所在的对象（环境）。这本来并不会让用户糊涂，但是 JavaScript 支持运行环境动态切换，也就是说，<code>this</code>的指向是动态的，没有办法事先确定到底指向哪个对象。</p>
<p>只要函数被赋给另一个变量，<code>this</code>的指向就会变。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var A = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  describe: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'姓名：'</span>+ this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var name = <span class="string">'李四'</span>;</span><br><span class="line">var f = A.describe;</span><br><span class="line">f() // <span class="string">"姓名：李四"</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>A.describe</code>被赋值给变量f，内部的<code>this</code>就会指向f运行时所在的对象（也就是<code>window</code>对象）。</p>
<h2 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h2><p><code>this</code>主要有以下几个使用场合。</p>
<h3 id="全局环境"><a href="#全局环境" class="headerlink" title="全局环境"></a>全局环境</h3><p>全局环境使用<code>this</code>，它指的就是顶层对象<code>window</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this === window // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  console.log(this === window);</span><br><span class="line">&#125;</span><br><span class="line">f() // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码说明，不管是不是在函数内部，只要是在全局环境下运行，<code>this</code>就是指顶层对象<code>window</code>。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数中的<code>this</code>，指的是实例对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Obj = <span class="keyword">function</span> (p) &#123;</span><br><span class="line">  this.p = p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面代码定义了一个构造函数Obj。由于<code>this</code>指向实例对象，所以在构造函数内部定义<code>this.p</code>，就相当于定义实例对象有一个p属性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var o = new Obj(<span class="string">'Hello World!'</span>);</span><br><span class="line">o.p // <span class="string">"Hello World!"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="对象的方法"><a href="#对象的方法" class="headerlink" title="对象的方法"></a>对象的方法</h3><p>如果对象的方法里面包含<code>this</code>，<code>this</code>的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变<code>this</code>的指向。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj =&#123;</span><br><span class="line">  foo: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo() // obj</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj.foo</code>方法执行时，它内部的<code>this</code>指向<code>obj</code>。</p>
<p>如果<code>this</code>所在的方法不在对象的第一层，这时<code>this</code>只是指向当前一层的对象，而不会继承更上面的层。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">  p: <span class="string">'Hello'</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    m: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      console.log(this.p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.b.m() // undefined</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>a.b.m</code>方法在<code>a</code>对象的第二层，该方法内部的<code>this</code>不是指向<code>a</code>，而是指向<code>a.b</code>，因为实际执行的是下面的代码。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var b = &#123;</span><br><span class="line">  m: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">   console.log(this.p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line">  p: <span class="string">'Hello'</span>,</span><br><span class="line">  b: b</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(a.b).m() // 等同于 b.m()</span><br></pre></td></tr></table></figure></p>
<p>如果要达到预期效果，只有写成下面这样。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">  b: &#123;</span><br><span class="line">    m: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      console.log(this.p);</span><br><span class="line">    &#125;,</span><br><span class="line">    p: <span class="string">'Hello'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果这时将嵌套对象内部的方法赋值给一个变量，this依然会指向全局对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">  b: &#123;</span><br><span class="line">    m: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      console.log(this.p);</span><br><span class="line">    &#125;,</span><br><span class="line">    p: <span class="string">'Hello'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var hello = a.b.m;</span><br><span class="line">hello() // undefined</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>m</code>是多层对象内部的一个方法。为求简便，将其赋值给<code>hello</code>变量，结果调用时，<code>this</code>指向了顶层对象。为了避免这个问题，可以只将<code>m</code>所在的对象赋值给<code>hello</code>，这样调用时，<code>this</code>的指向就不会变。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var hello = a.b;</span><br><span class="line">hello.m() // Hello</span><br></pre></td></tr></table></figure></p>
<h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><h3 id="避免多层-this"><a href="#避免多层-this" class="headerlink" title="避免多层 this"></a>避免多层 this</h3><p>由于<code>this</code>的指向是不确定的，所以切勿在函数中包含多层的<code>this</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  f1: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    var f2 = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">    &#125;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f1()</span><br><span class="line">// Object</span><br><span class="line">// Window</span><br></pre></td></tr></table></figure></p>
<p>上面代码包含两层<code>this</code>，结果运行后，第一层指向对象<code>o</code>，第二层指向全局对象，因为实际执行的是下面的代码。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var temp = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var o = &#123;</span><br><span class="line">  f1: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    var f2 = temp();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个解决方法是在第二层改用一个指向外层<code>this</code>的变量。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  f1: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    var that = this;</span><br><span class="line">    var f2 = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      console.log(that);</span><br><span class="line">    &#125;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f1()</span><br><span class="line">// Object</span><br><span class="line">// Object</span><br></pre></td></tr></table></figure></p>
<p>上面代码定义了变量<code>that</code>，固定指向外层的<code>this</code>，然后在内层使用<code>that</code>，就不会发生<code>this</code>指向的改变。</p>
<p>事实上，使用一个变量固定<code>this</code>的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。</p>
<p>JavaScript 提供了严格模式，也可以硬性避免这种问题。<strong>严格模式下，如果函数内部的<code>this</code>指向顶层对象，就会报错。</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var counter = &#123;</span><br><span class="line">  count: 0</span><br><span class="line">&#125;;</span><br><span class="line">counter.inc = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="string">'use strict'</span>;</span><br><span class="line">  this.count++</span><br><span class="line">&#125;;</span><br><span class="line">var f = counter.inc;</span><br><span class="line">f()</span><br><span class="line">// TypeError: Cannot <span class="built_in">read</span> property <span class="string">'count'</span> of undefined</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，inc方法通过’use strict’声明采用严格模式，这时内部的<code>this</code>一旦指向顶层对象，就会报错。</p>
<h3 id="避免数组处理方法中的-this"><a href="#避免数组处理方法中的-this" class="headerlink" title="避免数组处理方法中的 this"></a>避免数组处理方法中的 <code>this</code></h3><p>数组的<code>map</code>和<code>foreach</code>方法，允许提供一个函数作为参数。这个函数内部不应该使用<code>this</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  v: <span class="string">'hello'</span>,</span><br><span class="line">  p: [ <span class="string">'a1'</span>, <span class="string">'a2'</span> ],</span><br><span class="line">  f: <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">    this.p.forEach(<span class="keyword">function</span> (item) &#123;</span><br><span class="line">      console.log(this.v + <span class="string">' '</span> + item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f()</span><br><span class="line">// undefined a1</span><br><span class="line">// undefined a2</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>foreach</code>方法的回调函数中的<code>this</code>，其实是指向<code>window</code>对象，因此取不到<code>o.v</code>的值。原因跟上一段的多层<code>this</code>是一样的，就是内层的<code>this</code>不指向外部，而指向顶层对象。</p>
<p>解决这个问题的一种方法，就是前面提到的，使用中间变量固定<code>this</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  v: <span class="string">'hello'</span>,</span><br><span class="line">  p: [ <span class="string">'a1'</span>, <span class="string">'a2'</span> ],</span><br><span class="line">  f: <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">    var that = this;</span><br><span class="line">    this.p.forEach(<span class="keyword">function</span> (item) &#123;</span><br><span class="line">      console.log(that.v+<span class="string">' '</span>+item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f()</span><br><span class="line">// hello a1</span><br><span class="line">// hello a2</span><br></pre></td></tr></table></figure></p>
<p>另一种方法是将<code>this</code>当作<code>foreach</code>方法的第二个参数，固定它的运行环境。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  v: <span class="string">'hello'</span>,</span><br><span class="line">  p: [ <span class="string">'a1'</span>, <span class="string">'a2'</span> ],</span><br><span class="line">  f: <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">    this.p.forEach(<span class="keyword">function</span> (item) &#123;</span><br><span class="line">      console.log(this.v + <span class="string">' '</span> + item);</span><br><span class="line">    &#125;, this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f()</span><br><span class="line">// hello a1</span><br><span class="line">// hello a2</span><br></pre></td></tr></table></figure></p>
<h3 id="避免回调函数中的-this"><a href="#避免回调函数中的-this" class="headerlink" title="避免回调函数中的 this"></a>避免回调函数中的 <code>this</code></h3><p>回调函数中的<code>this</code>往往会改变指向，最好避免使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var o = new Object();</span><br><span class="line">o.f = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  console.log(this === o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// jQuery 的写法</span><br><span class="line">$(<span class="string">'#button'</span>).on(<span class="string">'click'</span>, o.f);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，点击按钮以后，控制台会显示<code>false</code>。原因是此时<code>this</code>不再指向<code>o</code>对象，而是指向按钮的 DOM 对象，因为<code>f</code>方法是在按钮对象的环境中被调用的。这种细微的差别，很容易在编程中忽视，导致难以察觉的错误。</p>
<p>为了解决这个问题，可以采用下面的一些方法对<code>this</code>进行绑定，也就是使得<code>this</code>固定指向某个对象，减少不确定性。</p>
<h2 id="绑定-this-的方法"><a href="#绑定-this-的方法" class="headerlink" title="绑定 this 的方法"></a>绑定 <code>this</code> 的方法</h2><p><code>this</code>的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把<code>this</code>固定下来，避免出现意想不到的情况。JavaScript 提供了<code>call</code>、<code>apply</code>、<code>bind</code>这三个方法，来切换/固定<code>this</code>的指向。</p>
<h3 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a><code>Function.prototype.call()</code></h3><p>函数实例的<code>call</code>方法，可以指定函数内部<code>this</code>的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var f = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> this;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">f() === window // <span class="literal">true</span></span><br><span class="line">f.call(obj) === obj // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，全局环境运行函数<code>f</code>时，<code>this</code>指向全局环境（浏览器为<code>window</code>对象）；<code>call</code>方法可以改变<code>this</code>的指向，指定<code>this</code>指向对象<code>obj</code>，然后在对象<code>obj</code>的作用域中运行函数<code>f</code>。</p>
<p><code>call</code>方法的参数，应该是一个对象。如果参数为空、<code>null</code>和<code>undefined</code>，则默认传入全局对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var n = 123;</span><br><span class="line">var obj = &#123; n: 456 &#125;;</span><br><span class="line"></span><br><span class="line">function a() &#123;</span><br><span class="line">  console.log(this.n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.call() // 123</span><br><span class="line">a.call(null) // 123</span><br><span class="line">a.call(undefined) // 123</span><br><span class="line">a.call(window) // 123</span><br><span class="line">a.call(obj) // 456</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>a</code>函数中的<code>this</code>关键字，如果指向全局对象，返回结果为123。如果使用<code>call</code>方法将<code>this</code>关键字指向<code>obj</code>对象，返回结果为456。可以看到，如果<code>call</code>方法没有参数，或者参数为<code>null</code>或<code>undefined</code>，则等同于指向全局对象。</p>
<p>如果<code>call</code>方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入<code>call</code>方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var f = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> this;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">f.call(5)</span><br><span class="line">// Number &#123;[[PrimitiveValue]]: 5&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>call</code>的参数为5，不是对象，会被自动转成包装对象（<code>Number</code>的实例），绑定f内部的<code>this</code>。</p>
<p><code>call</code>方法还可以接受多个参数。</p>
<p><code>func.call(thisValue, arg1, arg2, ...)</code></p>
<p><code>call</code>的第一个参数就是<code>this</code>所要指向的那个对象，后面的参数则是函数调用时所需的参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> add(a, b) &#123;</span><br><span class="line">  <span class="built_in">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add.call(this, 1, 2) // 3</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>call</code>方法指定函数<code>add</code>内部的<code>this</code>绑定当前环境（对象），并且参数为1和2，因此函数<code>add</code>运行后得到3。</p>
<p><code>call</code>方法的一个应用是调用对象的原生方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.hasOwnProperty.call(obj, <span class="string">'toString'</span>) // <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a><code>Function.prototype.apply()</code></h3><p><code>apply</code>方法的作用与<code>call</code>方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。</p>
<p><code>func.apply(thisValue, [arg1, arg2, ...])</code></p>
<p><code>apply</code>方法的第一个参数也是<code>this</code>所要指向的那个对象，如果设为<code>null</code>或<code>undefined</code>，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在<code>call</code>方法中必须一个个添加，但是在<code>apply</code>方法中，必须以数组形式添加。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(x, y)&#123;</span><br><span class="line">  console.log(x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.call(null, 1, 1) // 2</span><br><span class="line">f.apply(null, [1, 1]) // 2</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，f函数本来接受两个参数，使用<code>apply</code>方法以后，就变成可以接受一个数组作为参数。</p>
<p>利用这一点，可以做一些有趣的应用。</p>
<p><strong>1. 找出数组最大元素</strong></p>
<p>JavaScript 不提供找出数组最大元素的函数。结合使用<code>apply</code>方法和<code>Math.max</code>方法，就可以返回数组的最大元素。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [10, 2, 4, 15, 9];</span><br><span class="line">Math.max.apply(null, a) // 15</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 将数组的空元素变为<code>undefined</code></strong></p>
<p>通过<code>apply</code>方法，利用<code>Array</code>构造函数将数组的空元素变成<code>undefined</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.apply(null, [<span class="string">'a'</span>, ,<span class="string">'b'</span>])</span><br><span class="line">// [ <span class="string">'a'</span>, undefined, <span class="string">'b'</span> ]</span><br></pre></td></tr></table></figure></p>
<p>空元素与<code>undefined</code>的差别在于，数组的<code>forEach</code>方法会跳过空元素，但是不会跳过<code>undefined</code>。因此，遍历内部元素的时候，会得到不同的结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a = [<span class="string">'a'</span>, , <span class="string">'b'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="built_in">print</span>(i) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.forEach(<span class="built_in">print</span>)</span><br><span class="line">// a</span><br><span class="line">// b</span><br><span class="line"></span><br><span class="line">Array.apply(null, a).forEach(<span class="built_in">print</span>)</span><br><span class="line">// a</span><br><span class="line">// undefined</span><br><span class="line">// b</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 转换类似数组的对象</strong></p>
<p>另外，利用数组对象的<code>slice</code>方法，可以将一个类似数组的对象（比如<code>arguments</code>对象）转为真正的数组。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.slice.apply(&#123;0: 1, length: 1&#125;) // [1]</span><br><span class="line">Array.prototype.slice.apply(&#123;0: 1&#125;) // []</span><br><span class="line">Array.prototype.slice.apply(&#123;0: 1, length: 2&#125;) // [1, undefined]</span><br><span class="line">Array.prototype.slice.apply(&#123;length: 1&#125;) // [undefined]</span><br></pre></td></tr></table></figure></p>
<p>上面代码的<code>apply</code>方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有<code>length</code>属性，以及相对应的数字键。</p>
<p><strong>4. 绑定回调函数的对象</strong></p>
<p>前面的按钮点击事件的例子，可以改写如下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var o = new Object();</span><br><span class="line"></span><br><span class="line">o.f = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  console.log(this === o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f = <span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">  o.f.apply(o);</span><br><span class="line">  // 或者 o.f.call(o);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// jQuery 的写法</span><br><span class="line">$(<span class="string">'#button'</span>).on(<span class="string">'click'</span>, f);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，点击按钮以后，控制台将会显示<code>true</code>。由于<code>apply</code>方法（或者<code>call</code>方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。更简洁的写法是采用下面介绍的<code>bind</code>方法。</p>
<blockquote>
<p>实现<code>Function.prototype.apply()</code>方法<br>原理: fn.apply(obj)，先通过obj.profn = fn将fn作为obj的某个临时属性profn，然后执行profn，执行完毕后将profn属性删除<br>知识点： <code>eval(String)</code>将计算字符串并执行其中的JavaScript代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//简单模拟Symbol属性</span><br><span class="line"><span class="keyword">function</span> mySymbol(obj) &#123;</span><br><span class="line">    var unique_proper = <span class="string">"00"</span> + Math.random();</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(unique_proper)) &#123;</span><br><span class="line">        arguments.callee(obj)//callee为arguments的一个属性，引用当前正在执行的函数体</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> unique_proper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//原生JavaScript封装apply方法</span><br><span class="line">Function.prototype.myApply = <span class="keyword">function</span>(context) &#123;</span><br><span class="line">    var context = context || window //传入参数为null/undefined时，指向window对象</span><br><span class="line">    var args = arguments[1] //获取传入的数组参数</span><br><span class="line">    var fn = mySymbol(context);</span><br><span class="line">    context[fn] = this //假想context对象预先不存在名为fn的属性</span><br><span class="line">    <span class="keyword">if</span> (args == void 0) &#123; //没有传入参数直接执行</span><br><span class="line">        <span class="built_in">return</span> context[fn]()</span><br><span class="line">    &#125;</span><br><span class="line">    var fnStr = <span class="string">'context[fn]('</span></span><br><span class="line">    <span class="keyword">for</span> (var i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">        //得到<span class="string">"context.fn(arg1,arg2,arg3...)"</span>这个字符串在，最后用<span class="built_in">eval</span>执行</span><br><span class="line">        fnStr += i == args.length - 1 ? args[i] : args[i] + <span class="string">','</span></span><br><span class="line">    &#125;</span><br><span class="line">    fnStr += <span class="string">')'</span></span><br><span class="line">    var returnValue = <span class="built_in">eval</span>(fnStr) //还是<span class="built_in">eval</span>强大</span><br><span class="line">    delete context[fn] //执行完毕之后删除这个属性</span><br><span class="line">    <span class="built_in">return</span> returnValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a><code>Function.prototype.bind()</code></h3><p><code>bind</code>方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date();</span><br><span class="line">d.getTime() // 1481869925657</span><br><span class="line"></span><br><span class="line">var <span class="built_in">print</span> = d.getTime;</span><br><span class="line"><span class="built_in">print</span>() // Uncaught TypeError: this is not a Date object.</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，我们将<code>d.getTime</code>方法赋给变量<code>print</code>，然后调用<code>print</code>就报错了。这是因为<code>getTime</code>方法内部的<code>this</code>，绑定<code>Date</code>对象的实例，赋给变量<code>print</code>以后，内部的<code>this</code>已经不指向<code>Date</code>对象的实例了。</p>
<p><code>bind</code>方法可以解决这个问题。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">print</span> = d.getTime.bind(d);</span><br><span class="line"><span class="built_in">print</span>() // 1481869925657</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>bind</code>方法将<code>getTime</code>方法内部的<code>this</code>绑定到d对象，这时就可以安全地将这个方法赋值给其他变量了。</p>
<p><code>bind</code>方法的参数就是所要绑定<code>this</code>的对象，下面是一个更清晰的例子。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var counter = &#123;</span><br><span class="line">  count: 0,</span><br><span class="line">  inc: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    this.count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var func = counter.inc.bind(counter);</span><br><span class="line">func();</span><br><span class="line">counter.count // 1</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>counter.inc</code>方法被赋值给变量<code>func</code>。这时必须用<code>bind</code>方法将<code>inc</code>内部的<code>this</code>，绑定到<code>counter</code>，否则就会出错。</p>
<p><code>this</code>绑定到其他对象也是可以的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var counter = &#123;</span><br><span class="line">  count: 0,</span><br><span class="line">  inc: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    this.count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  count: 100</span><br><span class="line">&#125;;</span><br><span class="line">var func = counter.inc.bind(obj);</span><br><span class="line">func();</span><br><span class="line">obj.count // 101</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>bind</code>方法将<code>inc</code>方法内部的<code>this</code>，绑定到<code>obj</code>对象。结果调用<code>func</code>函数以后，递增的就是<code>obj</code>内部的<code>count</code>属性。</p>
<p><code>bind</code>还可以接受更多的参数，将这些参数绑定原函数的参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var add = <span class="keyword">function</span> (x, y) &#123;</span><br><span class="line">  <span class="built_in">return</span> x * this.m + y * this.n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  m: 2,</span><br><span class="line">  n: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var newAdd = add.bind(obj, 5);</span><br><span class="line">newAdd(5) // 20</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>bind</code>方法除了绑定<code>this</code>对象，还将<code>add</code>函数的第一个参数x绑定成5，然后返回一个新函数<code>newAdd</code>，这个函数只要再接受一个参数y就能运行了。</p>
<p>如果<code>bind</code>方法的第一个参数是<code>null</code>或<code>undefined</code>，等于将<code>this</code>绑定到全局对象，函数运行时<code>this</code>指向顶层对象（浏览器为<code>window</code>）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> add(x, y) &#123;</span><br><span class="line">  <span class="built_in">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var plus5 = add.bind(null, 5);</span><br><span class="line">plus5(10) // 15</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，函数<code>add</code>内部并没有<code>this</code>，使用<code>bind</code>方法的主要目的是绑定参数x，以后每次运行新函数<code>plus5</code>，就只需要提供另一个参数y就够了。而且因为<code>add</code>内部没有<code>this</code>，所以<code>bind</code>的第一个参数是<code>null</code>，不过这里如果是其他对象，也没有影响。</p>
<p><code>bind</code>方法有一些使用注意点。</p>
<p><strong>1. 每一次返回一个新函数</strong></p>
<p><code>bind</code>方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。</p>
<p><code>element.addEventListener(&#39;click&#39;, o.m.bind(o));</code></p>
<p>上面代码中，<code>click</code>事件绑定<code>bind</code>方法生成的一个匿名函数。这样会导致无法取消绑定，所以，下面的代码是无效的。</p>
<p><code>element.removeEventListener(&#39;click&#39;, o.m.bind(o));</code></p>
<p>正确的方法是写成下面这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var listener = o.m.bind(o);</span><br><span class="line">element.addEventListener(<span class="string">'click'</span>, listener);</span><br><span class="line">//  ...</span><br><span class="line">element.removeEventListener(<span class="string">'click'</span>, listener);</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 结合回调函数使用</strong></p>
<p>回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含<code>this</code>的方法直接当作回调函数。解决方法就是使用<code>bind</code>方法，将<code>counter.inc</code>绑定<code>counter</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var counter = &#123;</span><br><span class="line">  count: 0,</span><br><span class="line">  inc: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    <span class="string">'use strict'</span>;</span><br><span class="line">    this.count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> callIt(callback) &#123;</span><br><span class="line">  callback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">callIt(counter.inc.bind(counter));</span><br><span class="line">counter.count // 1</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>callIt</code>方法会调用回调函数。这时如果直接把<code>counter.inc</code>传入，调用时<code>counter.inc</code>内部的<code>this</code>就会指向全局对象。使用<code>bind</code>方法将<code>counter.inc</code>绑定<code>counter</code>以后，就不会有这个问题，<code>this</code>总是指向<code>counter</code>。</p>
<p>还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的<code>this</code>指向，很可能也会出错。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  <span class="built_in">times</span>: [1, 2, 3],</span><br><span class="line">  <span class="built_in">print</span>: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    this.times.forEach(<span class="keyword">function</span> (n) &#123;</span><br><span class="line">      console.log(this.name);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.print()</span><br><span class="line">// 没有任何输出</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>obj.print</code>内部<code>this.times</code>的<code>this</code>是指向<code>obj</code>的，这个没有问题。但是，<code>forEach</code>方法的回调函数内部的<code>this.name</code>却是指向全局对象，导致没有办法取到值。稍微改动一下，就可以看得更清楚。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">obj.print = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  this.times.forEach(<span class="keyword">function</span> (n) &#123;</span><br><span class="line">    console.log(this === window);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.print()</span><br><span class="line">// <span class="literal">true</span></span><br><span class="line">// <span class="literal">true</span></span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>解决这个问题，也是通过<code>bind</code>方法绑定<code>this</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">obj.print = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  this.times.forEach(<span class="keyword">function</span> (n) &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;.<span class="built_in">bind</span>(this));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.print()</span><br><span class="line">// 张三</span><br><span class="line">// 张三</span><br><span class="line">// 张三</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 结合<code>call</code>方法使用</strong></p>
<p>利用<code>bind</code>方法，可以改写一些 JavaScript 原生方法的使用形式，以数组的<code>slice</code>方法为例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].slice(0, 1) // [1]</span><br><span class="line">// 等同于</span><br><span class="line">Array.prototype.slice.call([1, 2, 3], 0, 1) // [1]</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，数组的<code>slice</code>方法从[1, 2, 3]里面，按照指定位置和长度切分出另一个数组。这样做的本质是在[1, 2, 3]上面调用<code>Array.prototype.slice</code>方法，因此可以用<code>call</code>方法表达这个过程，得到同样的结果。</p>
<p><code>call</code>方法实质上是调用<code>Function.prototype.call</code>方法，因此上面的表达式可以用<code>bind</code>方法改写。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var slice = Function.prototype.call.bind(Array.prototype.slice);</span><br><span class="line">slice([1, 2, 3], 0, 1) // [1]</span><br></pre></td></tr></table></figure></p>
<p>上面代码的含义就是，将<code>Array.prototype.slice</code>变成<code>Function.prototype.call</code>方法所在的对象，调用时就变成了<code>Array.prototype.slice.call</code>。类似的写法还可以用于其他数组方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var push = Function.prototype.call.bind(Array.prototype.push);</span><br><span class="line">var pop = Function.prototype.call.bind(Array.prototype.pop);</span><br><span class="line"></span><br><span class="line">var a = [1 ,2 ,3];</span><br><span class="line">push(a, 4)</span><br><span class="line">a // [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">pop(a)</span><br><span class="line">a // [1, 2, 3]</span><br></pre></td></tr></table></figure></p>
<p>如果再进一步，将<code>Function.prototype.call</code>方法绑定到<code>Function.prototype.bind</code>对象，就意味着<code>bind</code>的调用形式也可以被改写。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  console.log(this.v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o = &#123; v: 123 &#125;;</span><br><span class="line">var <span class="built_in">bind</span> = Function.prototype.call.bind(Function.prototype.bind);</span><br><span class="line"><span class="built_in">bind</span>(f, o)() // 123</span><br></pre></td></tr></table></figure></p>
<p>上面代码的含义就是，将<code>Function.prototype.bind</code>方法绑定在<code>Function.prototype.call</code>上面，所以<code>bind</code>方法就可以直接使用，不需要在函数实例上使用。</p>
<blockquote>
<p>实现<code>Function.prototype.bind()</code>方法<br>原理：使用<code>Function.prototype.apply()</code>来绑定函数体内的<code>this</code>，然后将一个参数以外的其他参数（<code>this = [].shift.apply(arguments)</code>,参数为arguments或者<code>Array.prototype.slice.call(arguments,1)</code>）作为提供给原函数的预设参数。需要用到柯理化<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  Function.prototype.myBind = Function.prototype.bind || <span class="keyword">function</span>(context)&#123;</span><br><span class="line">    <span class="keyword">if</span> (typeof this !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      // 调用<span class="built_in">bind</span>方法一定是函数，<span class="built_in">bind</span>返回的函数可以作为构造函数使用</span><br><span class="line">      throw new TypeError(<span class="string">'Function.prototype.bind - what is trying to be bound is not callable'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //<span class="built_in">bind</span>函数的参数</span><br><span class="line">    var aArgs   = Array.prototype.slice.call(arguments, 1),</span><br><span class="line">        fToBind = this,</span><br><span class="line">        fNOP    = <span class="function"><span class="title">function</span></span>() &#123;&#125;,</span><br><span class="line">        fBound  = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">          // this instanceof fBound === <span class="literal">true</span>时,说明返回的fBound被当做new的构造函数调用</span><br><span class="line">          //<span class="built_in">bind</span>返回的函数当构造函数使用时，绑定的this被忽略</span><br><span class="line">          <span class="built_in">return</span> fToBind.myApply(this instanceof fBound</span><br><span class="line">                 ? this</span><br><span class="line">                 : context,</span><br><span class="line">                 // 获取调用时(fBound)的传参.<span class="built_in">bind</span> 返回的函数入参往往是这么传递的</span><br><span class="line">                 aArgs.concat(Array.prototype.slice.call(arguments)));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    // 维护原型关系</span><br><span class="line">    <span class="keyword">if</span> (this.prototype) &#123;</span><br><span class="line">      // Function.prototype doesn<span class="string">'t have a prototype property</span></span><br><span class="line"><span class="string">      fNOP.prototype = this.prototype; </span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    // 下行的代码使fBound.prototype是fNOP的实例,因此</span></span><br><span class="line"><span class="string">    // 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例</span></span><br><span class="line"><span class="string">    fBound.prototype = new fNOP();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return fBound;</span></span><br><span class="line"><span class="string">  &#125;;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>this</code>是在执行的时候才能确认，定义的时候不能确认</li>
<li>函数由new进行调用,<code>this</code>指向新创建的对象</li>
<li>函数由<code>dot(.)</code>进行调用，<code>this</code>指向<code>dot</code>之前的对象</li>
<li>其他情况，<code>this</code>指向全局对象window</li>
<li><code>call</code>、<code>apply</code>:<ul>
<li>apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；</li>
<li>apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；</li>
<li>apply 、 call 、bind 三者都可以利用后续参数传参；</li>
<li>bind是返回对应函数，便于稍后调用；apply、call则是立即调用</li>
</ul>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/11/rem单位引用/" rel="next" title="rem单位引用">
                <i class="fa fa-chevron-left"></i> rem单位引用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/13/chrome调试SASS/" rel="prev" title="chrome调试SASS">
                chrome调试SASS <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/my.jpg"
                alt="Aishlily" />
            
              <p class="site-author-name" itemprop="name">Aishlily</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">114</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Aishlily" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:mali_job@yeah.net" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用场合"><span class="nav-number">1.</span> <span class="nav-text">使用场合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#全局环境"><span class="nav-number">1.1.</span> <span class="nav-text">全局环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数"><span class="nav-number">1.2.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的方法"><span class="nav-number">1.3.</span> <span class="nav-text">对象的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用注意点"><span class="nav-number">2.</span> <span class="nav-text">使用注意点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#避免多层-this"><span class="nav-number">2.1.</span> <span class="nav-text">避免多层 this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#避免数组处理方法中的-this"><span class="nav-number">2.2.</span> <span class="nav-text">避免数组处理方法中的 this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#避免回调函数中的-this"><span class="nav-number">2.3.</span> <span class="nav-text">避免回调函数中的 this</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#绑定-this-的方法"><span class="nav-number">3.</span> <span class="nav-text">绑定 this 的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Function-prototype-call"><span class="nav-number">3.1.</span> <span class="nav-text">Function.prototype.call()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Function-prototype-apply"><span class="nav-number">3.2.</span> <span class="nav-text">Function.prototype.apply()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Function-prototype-bind"><span class="nav-number">3.3.</span> <span class="nav-text">Function.prototype.bind()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Aishlily</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  
  <script type="text/javascript" src="/js/src/exturl.js?v=5.1.4"></script>


</body>
</html>
<script type="text/javascript" src="/js/src/love.js"></script>>